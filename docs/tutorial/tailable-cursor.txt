===============
Tailable Cursor
===============

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

When MongoDB executes an aggregate, it returns a
:phpclass:`MongoDB\\Driver\\Cursor <\MongoDB\Driver\Cursor>`.
The Cursor class implements the :php:`PHP Traversable interface
<manual/en/class.traversable.php>`. According to the PHP docs, the Traversable
interface cannot be implemented alone and must be implemented by
:php:`IteratorAggregate <manual/en/class.iteratoraggregate.php>` or
:php:`Iterator <manual/en/class.iterator.php>`. We can wrap a Cursor
in an Iterator or an IteratorAggregate.

A :manual:`tailable cursor <\reference\method\cursor.tailable>` is a cursor that
remains open even after reaching the end of the collection. This allows
applications to wait for changes to the collection and then iterate over the new
data.

Wrapping a Cursor
------------------

Find
~~~~~~~~~~~~~~~~~~~~

The following example finds restaurants based on the ``cuisine`` and ``borough``
fields and uses a :manual:`projection
</tutorial/project-fields-from-query-results>` to limit the fields that are
returned. It also limits the results to 5 documents. We can wrap the cursor in
an IteratorIterator and print each result. If we try to call :code:`next()`
after all of the results have been accessed, a RuntimeException will be thrown
by the driver.

.. code-block:: php

   <?php

   $collection = (new MongoDB\Client)->test->restaurants;

   $cursor = $collection->find(
      [
         'cuisine' => 'Italian',
         'borough' => 'Manhattan',
      ],
      [
         'limit' => 5,
         'projection' => [
            'name' => 1,
            'borough' => 1,
            'cuisine' => 1,
         ],
      ]
   );

Now we can view the results with a :code:`foreach`.

.. code-block:: php

   foreach (new IteratorIterator($cursor) as $document) {
      var_dump($document);
   }

The IteratorIterator equivalent of the above :code:`foreach` follows.

.. code-block:: php

   $iterator = new IteratorIterator($cursor);

   $iterator->rewind();

   while ($iterator->valid()) {
      $document = $iterator->current();
      var_dump($document);
      $iterator->next();
   }

Note that calling :code:`$iterator->next()` again will result in an exception since
we've exhausted :code:`$cursor`.

Wrapping a Tailable Cursor
---------------------------------

The following example wraps a tailable cursor in an IteratorIterator.

.. code-block:: php

   <?php

   $manager = new MongoDB\Driver\Manager(STANDALONE);
   $manager->executeCommand(DATABASE_NAME, new MongoDB\Driver\Command([
      'create' => COLLECTION_NAME,
      'capped' => true,
      'size' => 1048576,
   ]));

   $bulkWrite = new MongoDB\Driver\BulkWrite;
   $bulkWrite->insert(['_id' => 1]);
   $manager->executeBulkWrite(NS, $bulkWrite);
   $cursor = $manager->executeQuery(NS, new MongoDB\Driver\Query([], [
      'tailable' => true,
      'awaitData' => true,
      'maxAwaitTimeMS' => 10,
   ]));

   foreach (new IteratorIterator($cursor) as $document) {
      var_dump($document);
   }

If we try to iterate through these results with a :code:`foreach` as above, we
will only receive a single batch of results. Another :code:`foreach` won't work
because that attempts to rewind the cursor, which isn't allowed as all cursors
only support forward iteration. Since this is a tailable cursor, a call to
:code:`iterator->next()` will block for new results instead of throwing an
exception. We can use :code:`valid()` after a blocking call to :code:`next()` to
check if there is new data available.

.. code-block:: php

   $iterator = new IteratorIterator($cursor);

   $iterator->rewind();

   while ($iterator->valid()) {
      $document = $iterator->current();
      var_dump($document);
      $iterator->next();
   }

   $iterator->next();

   if ($iterator->valid()) {
      $document = $iterator->current();
      var_dump($document);
   }

